-----------------------old draw manager stuff-------------------------------------

export const drawActors = (actors: CheckpointActor[]) => {
  actors.forEach((actor) => {
    const defeated = actor.currentHealth <= 0;
    const imgType = defeated ? ImageType.GRAVESTONE : actor.isHero ? ImageType.HERO : imageByActorType(actor.type);
    const img = drawDatas.get(imgType)!.image();
    drawActor(
      actor,
      img,
      {
        x: actor.position.x,
        y: actor.position.y,
      },
      {
        width: defeated ? img.width * 0.07 : actor.isHero ? img.width * 0.25 : 112,
        height: defeated ? img.width * 0.07 : actor.isHero ? img.height * 0.25 : 120,
      }
    );
  });
};

const drawActor = (actor: CheckpointActor, img: any, pos: Position, dim: Dimensions) => {
  dynamicCanvasCtx.drawImage(img, pos.x, pos.y, dim.width, dim.height);

  if (actor.currentHealth > 0) {
    drawText(dynamicCanvasCtx, `${actor.currentHealth}/${actor.totalHealth}`, pos, 18, "red");
  }
};


--------------------timers, but working realy BAD-----------------------------

const CheckpointProcessOld = ({ checkpoint, heroes, checkpointPassed, closeCheckpoint }: CheckpointProcessProps) => {
  // const [images, setImages] = useState<Map<string, HTMLImageElement>>(new Map());
  const [seconds, setSeconds] = useState<number>(0);
  const [gifs, setGifs] = useState<Map<string, any>>(new Map());
  // const [eventMessages, setEventMessages] = useState<EventMessage[]>([]);
  const [actors, setActors] = useState<CheckpointActor[]>([]);
  const [canvasCtx, setCanvasCtx] = useState<CanvasRenderingContext2D>();
  const [inBattle, setInBattle] = useState<boolean>(false);
  const [loaded, setLoaded] = useState<boolean>(false);
  const [beginTime, setBeginTime] = useState<Date>();
  // const [drawCalls, setDrawCalls] = useState(0);

  const canvas = useRef<HTMLCanvasElement>({} as HTMLCanvasElement);

  const eventMessages: EventMessage[] = [];

  useEffect(() => {
    console.log("gifs");
    loadGifs().then((g) => {
      setGifs(g);
      if (gifs.size > 0) {
        setLoaded(true);
      }
    });
  }, [gifs]);

  useEffect(() => {
    console.log("actors");
    const acts = heroes.map((h) => convertToActor(h));
    if (checkpoint.enemies) {
      checkpoint.enemies.forEach((e) => acts.push(convertToActor(e)));
    }
    setActors(acts);
  }, [heroes, checkpoint.enemies]);

  useEffect(() => {
    console.log("canvas");
    if (canvas.current.getContext("2d")) {
      setCanvasCtx(canvas.current.getContext("2d")!);
      canvas.current.getContext("2d")!.clearRect(0, 0, canvas.current.width, canvas.current.height);
    }
  }, [canvas]);

  useEffect(() => {
    console.log("timers");
    let frameTimer: any;
    let secTimer: any;

    if (loaded) {
      console.log("timers 2");
      frameTimer = setInterval(() => update(), 1000 / 40);
      secTimer = setInterval(() => updateSec(), 1000);

      eventMessages.push({
        fireTime: new Date(),
        fontSize: 72,
        message: "BEGIN",
        color: color(255, 255),
        direction: Direction.CENTER,
        effect: Effect.FADE_IN_OUT,
      });

      setBeginTime(new Date());
    }

    return () => {
      clearInterval(frameTimer);
      clearInterval(secTimer);
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [loaded]);

  if (!checkpoint) {
    return null;
  }

  const update = () => {
    if (loaded) {
      if (canvasCtx) {
        canvasCtx.clearRect(0, 0, canvas.current.width, canvas.current.height);
        drawActors(actors, gifs, canvasCtx);
        drawMessages(eventMessages, canvasCtx);
        if (!inBattle) {
          if (seconds >= 3) {
            setInBattle(true);
            //       // setSeconds(0);
            eventMessages.length = 0;
          }
        }
      }
    }
  };

  const updateSec = () => {
    if (loaded && beginTime) {
      setSeconds(Math.floor(new Date().getTime() - beginTime.getTime()) * 0.001);
      console.log(seconds, Math.floor((new Date().getTime() - beginTime.getTime()) * 0.001));
    }
  };

  // <div className="checkpoint-process__heroes"></div>
  // <div className="checkpoint-process__loot"></div>
  // <div className="checkpoint-process__enemies"></div>

  return (
    <div className="checkpoint-process__container">
      {!loaded ? <Loader message="Loading scene" /> : null}
      <canvas width={750} height={400} ref={canvas}></canvas>
    </div>
  );
};


--------------------Raw stats-----------------------------

/** Computes 'initial' hero stats without equipment surpluses */
 const getRawStat =
   <T extends StatsHolderResponse, U extends keyof T>(stat: U) =>
   (hero: T) =>
   (equipment: T[]): number => {
     return +hero[stat] - equipment.map((e: T) => +e[stat]).reduce((a, b) => a + b);
   };

 new PersonageStats(
   getRawStat("power")(response)(response.equipment),
   getRawStat("defence")(response)(response.equipment),
   getRawStat("vitality")(response)(response.equipment),
   getRawStat("initiative")(response)(response.equipment)
 ),

--------------------Multiply Update-----------------------------

const enrichedActivities = await enrichHeroActivities(heroActivities);
const values = [];

enrichedActivities.forEach((activity) => {
  const act = activity.activity;
  values.push(`
    (
      ${activity.hero_id},
      '${act.type}',
      ${act.activity_id ?? null}::integer,
      ${act.duration ?? null}::integer
    )
  `);
});

await query(
  "updateHeroActivity",
  `update public.hero_activity ha set
    activity_type = a.type,
    activity_id = a.activity_id,
    started_at = now(),
    duration = a.duration
    from (values
    ${values.join(",")}
    ) as a(hero_id, type, activity_id, duration)
    where ha.hero_id = a.hero_id`
);


--------------------ЗАГРУЗКА КАРТИНКИ И CANVAS-----------------------------
const GameplayPage = () => {
  const [houseImg, setHouseImg] = useState(null);
  const [houses, setHouses] = useState([]);

  const canvasRef = useRef(null);

  useEffect(() => {
    const img = new Image();
    img.src = housePng;
    img.onload = () => {
      setHouseImg(img);
    };
    setHouses([
      {
        id: 1,
        type: "TAVERN",
        position: { x: 3, y: 2 },
      },
      {
        id: 2,
        type: "GUILD",
        position: { x: 6, y: 5 },
      },
    ]);
  }, []);

  useEffect(() => {
    const canvas = canvasRef.current;
    const context = canvas.getContext("2d");

    if (houseImg) {
      context.fillStyle = "#fddca5";
      context.fillRect(0, 0, canvas.width, canvas.height);

      houses.forEach((h) => {
        context.drawImage(houseImg, h.position.x, h.position.y, 64, 64);
      });
    }
  }, [houseImg, houses]);

  const clickHandler = (event) => {
    console.log(event.screenX, event.screenY);
  };

  return (
    <div className="gameplay">
      <div className="gameplay__world" onClick={clickHandler}>
        <canvas ref={canvasRef} width={800} height={600} />
      </div>
    </div>
  );
};

export default GameplayPage;

--------------------СТИЛИ-----------------------------
// .gameplay {
//   display: flex;

//   &__world {
//     position: absolute;
//     top: 50%;
//     left: 50%;
//     transform: translate(-50%, -50%);
//   }
// }

.gameplay {
  display: block;
  width: calc(152rem / 1.4);
  height: calc(85.5rem / 1.4);
  background-color: #fddca5;

  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -45%);

  background-image: url(../../img/Village.jpg);
  background-size: cover;

  &__world {
    // display: grid;
    // grid-template-rows: repeat(8, 1fr);
    // grid-template-columns: repeat(10, 1fr);

    &__btn--building {
      position: absolute;
      background-size: inherit;
      cursor: crosshair;

      &-tavern {
        background-image: url(../../img/tavern_btn.svg);
        background-size: 100%;
        width: 90px;
        height: 90px;
        opacity: 0;

        &:hover {
          opacity: 0.3;
        }
      }

      &-guild {
        background-image: url(../../img/guild_btn.svg);
        background-size: 100%;
        width: 120px;
        height: 120px;
        opacity: 0;

        &:hover {
          opacity: 0.3;
        }
      }
    }
  }
}

// .house {
//   width: 8rem;
//   height: 8rem;

//   &--img {
//     height: 100%;
//     background-image: url(../../img/house.png);
//     background-size: contain;
//     background-repeat: no-repeat;
//   }

//   &--name {
//     display: flex;
//     flex: 1;
//     flex-grow: 1;
//     align-items: center;
//     align-self: center;
//   }
// }

